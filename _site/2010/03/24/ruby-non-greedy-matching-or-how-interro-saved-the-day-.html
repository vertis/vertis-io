<p>I&#39;ve spend most of the afternoon working on a complex regex in order to parse command line argument forms (for lack of a better term). If you&#39;ve ever run the man command you&#39;ll know what I&#39;m talking about. Take the tar command as an example:</p>
<pre><span class="Apple-style-span" style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; ">tar  [ - ] A --catenate --concatenate | c --create | d --diff --compare
       | --delete | r --append | t --list | u --update | x --extract  --get  [
       options ] pathname [ pathname ... ]
</span></pre>
<p>If you&#39;re already familiar with regular expressions you&#39;ll know that &nbsp;doing something like:</p>
<pre>[\[].*[\]]</pre>
<p>trying to match:&nbsp;</p>
<pre>[ - ]&nbsp;</pre>
<p>won&#39;t accomplish what you think. Instead of getting just the first set of braces you&#39;ll end up with the whole remainder of the string. This is because of a feature, we&#39;ll give it that title, called greedy matching. Greedy matching means that it takes the largest possible chunk that your regex will match, which in this case is the &#39;]&#39; on the end of pathname.</p>
<p>I was aware of what was going on, but not being a particular master of regular expressions, I wasn&#39;t sure how to get it to stop being greedy. As it turns out its quite easy.</p>
<ul>
	<li><span style="font-size:14px;"><strong>.*</strong>&nbsp;&nbsp; &nbsp;- Greedy matching<br />
		</span></li>
	<li><span style="font-size:14px;"><strong>.+ &nbsp;</strong>&nbsp;- Greedy matching<br />
		</span></li>
	<li><span style="font-size:14px;"><strong>.*?&nbsp;</strong> - Non-greedy matching<br />
		</span></li>
	<li><span style="font-size:14px;"><strong>.+?</strong> - Non-greedy matching<br />
		</span></li>
</ul>
<p>It could not be easier, once you know about it of course.</p>
