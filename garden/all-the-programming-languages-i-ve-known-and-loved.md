---
published: true
layout: post
title: "All The Languages I've Known And Loved"
author: vertis
minutes_read: 
feature_image:
  url: 
caption: ""
meta_description: ""
tags:
  - 
---
# PLiHKAL: A Geeky Love Story
## Introduction

I have known and loved many languages. Over the course of my life, I have experienced, explored, and appreciated the unique qualities and effects of a wide range of programming languages. Each has taught me something new, revealing aspects of myself and the world around me. They have been my teachers, my companions, and my guides on a journey of discovery and self-exploration.

Okay, enough with the ripping off a book that is of questionable legality. But the sentiment is true. Depending on when you start counting -- my first faltering steps or a bit later -- I've been programming for well over 20 years now. Each language I’ve used has taught me things, some I still love and some not so much.

Many have long since become legacy languages, slowly disappearing. Don't get me wrong. The first language I ever learned, C, is still a huge part of the underlying infrastructure of the entire world. But it's not what people think about when they go into programming now. I guess this is not really intended for anyone else so much as a list for me of everything that I've worked with.

Early Days
I mean, so I found my first real programming book when I was 14 or 15. It was [The C Programming Language](https://en.wikipedia.org/wiki/The_C_Programming_Language) by Brian Kernighan and
Dennis Ritchie. I still have the banged up copy I inherited from somewhere.

When I say “real”, I’d had brief encounters with those silly little BASIC books, with games that you could build, but I never had access to actually run them. They were flipped through and quickly forgotten.

I was at a point in my journey with computers where I finally had the ability to actually go and install the compiler, and actually compile some C code. It would be a long time after that before I learned more than badly written procedural programs.

This was a time when the internet was in its infancy, or at least my access to it. My access to programming predated my access to the internet by a year or so, if I recall correctly. While I would not return to being young, I envy the access to learning material that today’s children enjoy. 

It wasn't until university that I really, really learned. And then it wasn't C they were teaching, it was C++ and Java. And in some ways I resonated more with C than I did with C++. Despite the classes, I never really got into programming in C++. But C is still special to me, it was a gateway drug.

## University and Early Career
By the time I left university, I was doing a combination of Java and PHP and Perl. Java taught me rigour in a way that was missing in PHP and Perl. I have long since discovered that you can be a good or bad programmer in any language, but as a learner the rigour that came with Java was helpful. 

Ironically, it was a Pascal codebase that was my first big codebase that I owned, on Delphi 5 (or possibly 6). I'd written plenty of things on my own by this point. But I had poor timing of joining the tech industry at the low of the dot-com bust. There were little to no jobs, certainly not in the area I lived in.

I’ve written a little bit on /r/cscareerquestions, because the boom and bust cycle of programming jobs can be painful when you lack the context.

There was no Reddit in those days to go and complain on the subreddit about how many job applications I put in. Hell, there were no careers websites. I ended up doing computer work for the small local businesses that would have me. 

This eventually led to working with a small software business in Australia that had an incredibly seat-of-the-pants written codebase. They didn't even have source control for this codebase when I first interacted with it. Their idea of version control was taking a copy of the directory. 

Numerous parts of this application that had been compiled and then the source code for those compiled bits had been lost. I'm sure that's not a unique experience as there are a lot of stories about the classic computer games where the source code was expensive to keep around, the source for those games is lost forever. 

For all its flaws, it was a impressive codebase. And it was in use with a large number of auto parts recyclers in Australia. When I look back at this with the lens of a product focused developer I can appreciate how the software was a tool to get to solve a problem. 

Before owning this codebase I’d supported it directly with a few  customers. I’d come to understand what they saw in this application. I didn’t know about the code at the time, but even from the outside it had flaws and as a desktop application was not where the shiny new technology was.

I suggested it might be better implemented as a web app. The customers were incredibly resistant to this. The app was incredibly quick and had hotkeys. It was local so there was no dependence on a broadband connection in its infancy. While a PHP web app could have been delivered on premises, but it would have struggled to compete with the experience.

What I came to love about Delphi and Pascal was the speed at which you could deliver a GUI application. By the time I was working with it in 2005-2007 Delphi Pascal wasn't something that was moving forward in the world. It was at the end of its lifespan -- regardless, it had a lot to teach. 

From there I moved to building apps in Java. I will never love Java, but I have known Java. Fought with Java. Existed in the world of ANT, Swing and Eclipse. I have made Java do things it didn’t want to. I hated Java with intensity that caused me to build JRuby apps and install them in Enterprise Java Servers to avoid writing Java. May I never be forced to write Java again.


I discovered JavaScript in those early days, but JavaScript in those days abhorrent language and I ran away from JavaScript screaming. The only thing it had to teach then was how not to design a language. To this day language design decisions haunt us.

## Discovering Ruby
It wasn't until I discovered Ruby that I fell in love with a language. It was not an accident. Ruby had been designed to be a language that programmers fell in love with. I didn't really understand the benefits of working in a language that you fall in love with. It was like a surprise birthday party.

More, there were many things that Ruby taught me that weren't about the programming language at all. Lessons in the philosophy of programming and everything, everything that exists around it. 

I owe the Ruby (and Rails) community a debt that I can never repay, they made me a better programmer. 

You can say what you want about Ruby the language. Ruby the community, was something that built better programmers. It stopped being an isolated experience that I had, and the job that I did, and started being something that was part of a bigger community that was making each other better.

Even though I've long moved on from Ruby, and I wouldn't consider it my primary language anymore, I'm a Rubyist at heart. A fundamental part of the way I now develop and the way I approach technology comes from those experiences. This includes the Rails community, and 37signals (Rework).

Becoming part of the Ruby and Rails community, and going to Railscamps in Australia and New Zealand, made me part of a community. 

## Exploring Other Languages
Ironically, it was Ruby/Rails that started introducing me to languages as something that were loved and learned from.

Aside from drinking and playing Werewolf, people of people went to Railscamp and then did things that were not Rails. People in the community were passionate about becoming better programmers regardless of where that journey took you.

At least one guy that was constantly pushing Haskell at these Ruby events. I’m not sure how many people he converted, but it was greater than zero and a lot less than 10. If I had a Haskell program for it would be correct.

It was around that time that[Seven Languages in Seven Weeks](https://pragprog.com/titles/btlang/seven-languages-in-seven-weeks/) became a big thing. Encouraging the act of taking lessons from each of the languages, finding the good parts of and making yourself a better programmer. Someone even suggested that [Javascript might have good parts](https://www.oreilly.com/library/view/javascript-the-good/9780596517748/).

Each language, each framework, had lessons that you could take away and apply to other languages. Even if you weren’t going to be a Haskell programmer you could take concepts and apply them elsewhere.

Then it became shiny and hot to do “Isomorphic JavaScript”, with JavaScript on both the front-end and back-end. In ways it was useful, there was a certain amount of cognitive load switching backwards and forwards between two different languages, and web apps were getting much more JavaScript heavy on the front end.

Despite living and working with JavaScript and React after this point, and it became the shiny thing that my employers wanted it was not something that I enjoyed working with. I had lost my way. But JavaScript eventually gave way to TypeScript, and TypeScript I can live with.

## System Programming Languages
The “Seven Languages in Seven Weeks” attitude caused me to discover Elixir, Golang and Rust. Elixir was where I learned a bunch of functional programming. I don’t mind admitting that Haskell was a bridge too far.

I fell in love with modern system languages for a while. The advent of Golang and Rust neatly corresponded with a period in my career where I was doing a lot of DevOps work. It became cool, for me at least, because of Terraform (and other HashiCorp tools). 

Ruby was great, but Ruby was slow. Making Ruby fast relied on writing C/C++ code, for pieces that need to be fast. The weaknesses of C and C++ had given rise to new languages that would eventually be the ones that would take on the mantle of system languages. 

When the opportunity arose, I built command line tools in Golang. 

It’s not fair to compare the C of the late nineties with Golang, but coming from Ruby and equivalent high-level languages the package/library management felt familiar, even simpler in ways. Refer to things by the full URL to go and fetch them from Github or equivalent and it all JustWorked™. 

Golang was more write once and run everywhere than Java was despite all the Java claims. Java, Ruby, Python, PHP, and Perl are always require the language runtime SDK available. You could could get around this by building packages where it had its own version of the runtime. Golang, and Rust, were able to compile and then you had a binary that you could distribute.

## Game Programming

Many languages that I’ve used briefly enough that it wasn’t worth mentioning them. Both VB/VB.NET made brief appearances in my career in the early to mid-noughties. It wasn’t until I got the chance again to do game programming that C# made a serious attempt to get back into my life.

I came back to C# because of Unity 3D. It isn’t, or wasn’t at the time .Net, but Mono. But it's a distinction without importance in this case. The Game Programming aspects are a specialist subset.

In my late teens, I had this "Tricks of the Windows Game Programming Gurus" book, and I had been desperate, to do game programming. What could be more exciting, within computing, to a teenager. I couldn’t know that the games industry has a habit of burning people out. 

It was the late 90s and and despite the book , it was beyond my capabilities at the time. 

Here I was back at game programming because of VR. It wasn’t *true* games, I was building experiences for real estate. But it was a chance to touch those frameworks and to learn a huge amount from the way that, Unity3D is constructed. 

Unity3D has made a huge number of missteps recently. Gaffes that make it difficult to love the company. But the framework, the ecosystem I love.

It’s a different love than Ruby. Ruby is the free love of the 1960s. The let’s list everything under the MIT license and we’ll all succeed together. Unity3D is the love of a Ferengi that has spotted a pile of platinum. 

I know Unity3D isn’t a language. Don’t message me. Go build your games directly in a standard library if that’s what you want to do.

Little of my career has been using the visual editors that come with certain programming languages. Delphi being an early exception. 

It’s hard to imagine game programming without a visual editor though. The feedback loop would be bad without it. There is an elegance to the way things are wired up. The way scenes and projects are organised.

Building things in Unity3D helped make me a better programmer. In the same way that learning functional principles did. Having pieces that are isolates, decoupled and yet part of a greater whole is something best learned in game programming. Micro-services, to strain that definition beyond breaking. 

There are things, beyond games, that can be better built in Unity3D (or potentially Unity3Ds competitors) than they are in any other platform. I'm not sure I would go back and use it now, given the way that it has been run recently, which is the risk with any platform or language owned and driven by a company.

## SvelteKit

Again it’s not a language. If you haven’t worked out that the label of language and framework and the broader community beyond the language is a part of this essay, it’s late.

SvelteKit saved me from React. React, that corrupted and consumed everything for many years. I ran from React. You can build amazing experience with React, but it becomes all consuming, you become a React programmer. Jsx/Tsx feels neat until you spend your whole life rewriting html to be jsx.

What was wrong with erb or equivalent that someone created the unholy entity that is Jsx. Regardless, it’s where we found ourselves. Svelte and SvelteKit has given me a path out when it comes to web development.

It’s much closer to the Rails of my past with the availability a passing level of type safety through TypeScript.

## Who Could Forget Python

I wish I could. I feel like there is enmity between the Python and Ruby communities that could see a Romeo and Juliet style tragedy play out. But you can’t avoid Python now. Python is machine learning, and machine learning is eating the world.

I don’t hate it as I once did. Somewhere along the line, I became a programmer that believes that the tool should format the code. Something I learned from Golang. Python’s indents are fine now.

Python’s horrible package management has not been tamed. They’ve instead invoked the xkcd standards strip repeatedly. I do like ipython/jupyter notebooks though. A good way to experiment quickly.

## AI and Low-Level Languages

Everything has changed now. I can claim to be familiar with about a dozen languages, and many more frameworks, but it matters less now. Many projects were the domain of high-level languages and would have required infinitely more work in one of the system languages.

But that is changing, artificial intelligence (AI), large language models (LLM) are changing what it means to program.

With the advent of LLM, it has become much, much easier to approach languages that I don't use. I had dabbled in Rust, but never did enough Rust to become good at it. 

Rust, like Golang has a number of concepts that will trip you up as a beginner. Send you running back to the documentation trying to work out what would otherwise be a simple task. Or back to a high-level language that hides that.

This was a problem if you haven’t used the language recently. 

The loop has changed. The act of programming is changing. Becoming a guider of AI. One product is called copilot, though it is quickly becoming the human that is the copilot. I suspect the languages themselves will soon change to better enable AI to  write them. Meeting somewhere in the middle.

The generalist, is the current winner here. Eventually we might not be needed. Not in that way. Reinventing ourselves as many others have had to when disrupted.